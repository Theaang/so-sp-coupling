---
title: "SO-SP Coupling and Memory Consolidation â€” Effect Size Preprocessing"
format: html
editor: visual
author: "Author"
date: "2023-07-28"
date-format: iso
toc: true
---

```{r}
#| warning: false
#| message: false
#| label: setup
## Load required packages
library(mosaic)
library(tidyverse)
library(knitr)
library(kableExtra)
library(tidyr)
library(Stat2Data)
library(dplyr)
library(meta)
library(metafor)
library(dmetar)
library(metaDigitise)
library(ICC)
library(wildmeta)
library(future)
library(shinyDigitise)
library(CircStats)
library(Directional)
options(digits = 4)
knitr::opts_chunk$set(fig.pos = "H", out.extra = "",
                      tidy=FALSE, size="small")
```

```{r}
#| warning: false
#| message: false
## All papers that provided source data and/or reported correlation in graphs
## have undergone preprocess to normalize the correlation coefficient
## After preprocessing in R, all correlation coefficients reported as pearson's
## r were transformed to Fisher's z by the Practical Meta-Analysis Effect Size 
## Calculator developed by Dr.Wilson
```

```{r}
#| warning: false
#| message: false
## Import graphs to shinyDigitise
## Could be downloaded from the Github repository
## Donnelly2022 <- shinyDigitise("~/Desktop/SO-SP-Coupling/so-sp-coupling/Paper/Donnelly2022/Figure/")
## Helfrich2018 <- shinyDigitise("~/Desktop/SO-SP-Coupling/so-sp-coupling/Paper/Helfrich2018/Figure/")
## Processed data saved in the same folder
```

```{r}
#| warning: false
#| message: false
## Import source data from Schreiner 2021
Schreiner2021 <- read_csv("https://raw.githubusercontent.com/Theaang/so-sp-coupling/main/Paper/Schreiner2021/Sourcedata/source-data-preprocessed.csv", show_col_types = FALSE)
## view(Schreiner2021)
```

```{r}
#| warning: false
#| message: false
## Calculate the circular linear correlation
circlin.cor <- circlin.cor(Schreiner2021$phase, Schreiner2021$retention, rads = TRUE)
R_squared <- circlin.cor[, 1]
Pearsons_r <- sqrt(R_squared)
data.frame(Pearsons_r, R_squared, row.names = NULL)
```

```{r}
#| include: false
## knitr::kable(result, format = "markdown")
```

```{r}
#| warning: false
#| message: false
## Calculate the coupling percentage and remove outlier(s)
Schreiner2021 <- Schreiner2021 |>
  mutate(
    spavg = (spobjects + spscenes)/2,
    cpavg = (cpobjects + cpscenes)/2,
    soavg = (soobjects + soscenes)/2,
    spsopct = cpavg/spavg,
    sosppct = cpavg/soavg)|>
  filter(!(abs(scale(spsopct)) > 3 | abs(scale(sosppct)) > 3))
```

```{r}
#| warning: false
#| message: false
## Calculate summary statistics for the coupling percentage
favstats(~ spsopct, data = Schreiner2021)
favstats(~ sosppct, data = Schreiner2021)
## Test the normality condition for further interpretation
shapiro.test(Schreiner2021$spsopct)
shapiro.test(Schreiner2021$sosppct)
## Calculate the linear correlation between SO coupled SP and memory retention
cor(spsopct ~ retention, use = "complete", data = Schreiner2021)
## Calculate the linear correlation between SP coupled SO and memory retention
cor(sosppct ~ retention, use = "complete", data = Schreiner2021)
```

```{r}
#| warning: false
#| message: false
## Import source data from Denis 2021a
Denis2021a <- read_csv("https://raw.githubusercontent.com/Theaang/so-sp-coupling/main/Paper/Denis2021a/Sourcedata/sleepldf_so_ss_data.csv", show_col_types = FALSE)
## view(Denis2021a)
```

```{r}
#| warning: false
#| message: false
## Filter out the stress group and remove outlier(s) for coupling strength
Denis2021a_str <- Denis2021a |>
  dplyr::select(cond, neu_hit_fa:neg_hit_fa, n3_cp_str_all)|>
  filter(cond == 2, !(abs(scale(as.vector(n3_cp_str_all))) > 3))|>
  mutate(avg_hit_fa = (neu_hit_fa*100 + emo_hit_fa*200)/300)
## Calculate summary statistics for the coupling percentage
favstats(~ n3_cp_str_all, data = Denis2021a_str)
## Test the normality condition for further interpretation
shapiro.test(Denis2021a_str$n3_cp_str_all)
## Note: The distribution of coupling strength data deviates significantly (p < 0.02)
## from the normal distribution
```

```{r}
#| warning: false
#| message: false
## Calculate the effect size for each emotional condition
cor(neu_hit_fa ~ n3_cp_str_all, use = "complete", data = Denis2021a_str)
cor(emo_hit_fa ~ n3_cp_str_all, use = "complete", data = Denis2021a_str)
cor(pos_hit_fa ~ n3_cp_str_all, use = "complete", data = Denis2021a_str)
cor(neg_hit_fa ~ n3_cp_str_all, use = "complete", data = Denis2021a_str)
## Calculate the weighted effect size for all conditions
avg_cor_str <- cor(avg_hit_fa ~ n3_cp_str_all, use = "complete", data = Denis2021a_str)
avg_cor_str
```

```{r}
#| warning: false
#| message: false
## Filter out the stress group and remove outlier(s) for coupling percentage
Denis2021a_per <- Denis2021a |>
  dplyr::select(cond, neu_hit_fa:neg_hit_fa, n3_cp_per_all)|>
  filter(cond == 2, !(abs(scale(as.vector(n3_cp_per_all))) > 3))|>
  mutate(avg_hit_fa = (neu_hit_fa*100 + emo_hit_fa*200)/300)
## Calculate summary statistics for the coupling percentage
favstats(~ n3_cp_per_all, data = Denis2021a_per)
## Test the normality condition for further interpretation
shapiro.test(Denis2021a_per$n3_cp_per_all)
```

```{r}
#| warning: false
#| message: false
## Calculate the effect size for each emotional condition
cor(neu_hit_fa ~ n3_cp_per_all, use = "complete", data = Denis2021a_per)
cor(emo_hit_fa ~ n3_cp_per_all, use = "complete", data = Denis2021a_per)
cor(pos_hit_fa ~ n3_cp_per_all, use = "complete", data = Denis2021a_per)
cor(neg_hit_fa ~ n3_cp_per_all, use = "complete", data = Denis2021a_per)
## Calculate the weighted effect size for all conditions
avg_cor_per <- cor(avg_hit_fa ~ n3_cp_per_all, use = "complete", data = Denis2021a_per)
avg_cor_per
```

```{r}
## Test robustness by the bootstrap method for nonnormality data
#> num_sim <- 10000
#> set.seed(1821)
#> bootstrap_result <- do(num_sim) * 
#>   cor(avg_hit_fa ~ n3_cp_str_all, data = resample(Denis2021a_str))
#> summary(bootstrap_result)

#> bootstrap_result <- as.numeric(bootstrap_result$cor)
#> ggplot(data.frame(x = bootstrap_result), aes(x = x)) +
#>   geom_histogram(binwidth = 0.05, color = "black", fill = "lightblue") +
#>   labs(title = "Histogram of Bootstrap Results",
#>        x = "Bootstrap Results (Pearson's r correlation)",
#>        y = "Frequency") +
#>   geom_vline(xintercept = mean(bootstrap_result), color = "black", linetype = "dashed") +
#>   geom_vline(xintercept = avg_cor, color = "black", linetype = "dashed")
```
